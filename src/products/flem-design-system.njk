<main>
<section>
    <h3>Principles</h3>
    <ul>
        <li><p><b>Playful:</b> users feel welcomed into the space and like they have a part to play there.</p></li>
        <li><p><b>Clear:</b> users can explore and find info easily.</p></li>
        <li><p><b>Emotional:</b> interactions, art, navigation, content should always point back to a relationship between them and the content.</p></li>
    </ul>
</section>

<section>
    <h3>Color</h3>
    <p>To maximize the impact of color, we utilize hue shifting and gradients</p>
    <p>Because we use hue shifting, we don't restrict ourselves to a primary color. Instead, we have a primary rotation and use whatever color stop creates the contrast and effect we're looking for. This allows for brand icons and other designs flow between different backgrounds seemlessly.</p>

    <h4>Customize the palette</h4>
    <form id="paletteGenerator" name="paletteGenerator">
        <canvas id="paletteCanvas" width="360" height="50"></canvas>
        <label for="startingHue">Hue</label><input id="startingHue" oninput="updatePalette()" type="range" min="0" max="360" value="185"/>
        <label for="shift">Hue Shift</label><input id="shift" oninput="updatePalette()" type="range" min="0" max="30" value="10"/>
        <label for="dynamicRange">Dynamic Range</label><input id="dynamicRange" oninput="updatePalette()" type="range" min="2" max="16" step="2" value="16" />
        <label for="rotations">Rotations</label><input id="rotations" oninput="updatePalette()" type="range" min="1" max="12" value="6"/>
        <label for="saturation">Saturation</label><input id="saturation" oninput="updatePalette()" type="range" min="1" max="100" value="40"/>
        <label for="saturation">Saturation Shift</label><input id="saturationShift" oninput="updatePalette()" type="range" min="1" max="100" value="50"/>
        <div id="huePreview"></div>
    </form>

    <h4>Color terms</h4>
    <ul>
        <li><p>Hue: A value between 0-360 which indicates where on the color wheel we are starting.</p></li>
        <li><p>Saturation: A value between 0-100 which specifies how close the color is to grey.</p></li>
        <li><p>Luminosity: For our purposes, the same as brightness. We use luminosity because CSS HSL colors use this term.</p></li>
        <li><p>Rotation: A list of colors which vary in hue and luminosity.</p></li>
        <li><p>Stop: A single color within a rotation. The name "stop" comes from the fact that we are "stopping" at certain luminosities to grab colors for our palette.</p></li>
        <li><p>Dynamic range: How many stops each rotation will have.</p></li>
        <li><p>Hue shift: In natural sunlight, colors head toward yellow as they get brighter and purple as they get darker. Hue shift pushes the values in these directions to create a more pleasing rotation.</p></li>
        <li><p>Saturation shift: Because it looks weird to have a light green background, it can be useful to desaturate colors as they become brighter. Saturation shift pushes brighter colors slightly toward white.</p></li>
    </ul>
</section>

<section>
    <h3>Font</h3>
    <h4>Font choice</h4>
    <p>Arial is the font for both headers and body text. There are two reasons for this.</p>
    <ol>
        <li><p>Arial is easier for people with dyslexia to read (<a href="https://www.bdadyslexia.org.uk/advice/employers/creating-a-dyslexia-friendly-workplace/dyslexia-friendly-style-guide#:~:text=Some%20dyslexic%20readers%20may%20request,excessive%20it%20can%20reduce%20readability.">source</a>).</p></li>
        <li><p>The font is web safe, which will slightly increase website performance.</p></li>
    </ol>
    <p>
        Any other font is acceptable as long as it's applied consistently to all headers and/or all body text throughout the site and it meets at least the first criteria above.
    </p>

    <h4>Font size</h4>
    <p>
        The base font size is 16px for all text. We scale in increments of the base grid size (8px) to get header sizes. h4 is the lowest header size available, starting at 24px.
    </p>

    <h4>Font spacing</h4>
    <ul>
        <li><p>Currently, letter spacing is set at default for Arial. If anyone knows better, let me know.</p></li>
        <li><p>Line height is 1.5 * the font size</p></li>
        <li><p>Margin top for headers is 1 * the font size</p></li>
        <li><p>Margin bottom for headers is 0.5 * the font size</p></li>
        <li><p>Margins top and bottom for body is 1 * the font size</p></li>
    </ul>

    <h4>Inline links</h4>
    <p>As per standards from the dyslexia-friendly-style-guide, links and other text are not underlined. Instead, like buttons, they are bold and a different color.</p>
    <a href="#inline-links">Inline Link</a>

    <p>Most of these choices are inspired by the <a href="https://www.bdadyslexia.org.uk/advice/employers/creating-a-dyslexia-friendly-workplace/dyslexia-friendly-style-guide#:~:text=Some%20dyslexic%20readers%20may%20request,excessive%20it%20can%20reduce%20readability.">British Dyslexia Association</a>.</p>
</section>


<section>
    <h3>Components</h3>

    <p>We prefer semantic HTML over class-based css. This makes it easy to render markdown pages and other situations where one may not want to have control over individual elements on the page. In cases where specific styling is needed, we use <a href="https://getbem.com/">BEM</a> naming conventions because they're awesome.</p>

    <h4>Forms</h4>
    <form>
    <label>input type="button"</label>
    <input type="button" value="Button">
    <label>input type="checkbox"</label>
    <input type="checkbox">
    <label>input type="color"</label>
    <input type="color">
    <label>input type="date"</label>
    <input type="date">
    <label>input type="datetime-local"</label>
    <input type="datetime-local">
    <label>input type="email"</label>
    <input type="email">
    <label>input type="file"</label>
    <input type="file">
    <label>input type="hidden"</label>
    <input type="hidden">
    <label>input type="image"</label>
    <input type="image">
    <label>input type="month"</label>
    <input type="month">
    <label>input type="number"</label>
    <input type="number">
    <label>input type="password"</label>
    <input type="password">
    <label>input type="radio"</label>
    <input type="radio">
    <label>input type="range"</label>
    <input type="range">
    <label>input type="reset"</label>
    <input type="reset">
    <label>input type="search"</label>
    <input type="search">
    <label>input type="submit"</label>
    <input type="submit">
    <label>input type="tel"</label>
    <input type="tel">
    <label>input type="text"</label>
    <input type="text">
    <label>input type="time"</label>
    <input type="time">
    <label>input type="url"</label>
    <input type="url">
    <label>input type="week"</label>
    <input type="week">
    <label>label</label>
    <label></label>
    <label>select</label>
    <select>
    <label>textarea</label>
    <textarea>
    <label>button</label>
    <button>
    <label>fieldset</label>
    <fieldset>
    <label>legend</label>
    <legend>
    <label>datalist</label>
    <datalist>
    <label>output</label>
    <output>
    <label>option</label>
    <option>
    <label>optgroup</label>
    <optgroup>
    </form>


    <h4>Buttons</h4>
    <button>Default button</button>
    <button class="button--action">Action button</button>
    <button class="button--danger">Danger button</button>
    <button class="button--disabled">Disabled button</button>

    <h4>Chips</h4>
    <button class="button--chip">chip 1</button>

    
</section>

<section>
    <h3>Layouts</h3>

    <h4>Document layout</h4>

    <ul>
        <li><p>Text is rendered inside a center aligned container with a max width of 600px.</p></li>
        <li><p>Suitable for markdown documents, documentation, etc.</p></li>
    </ul>

    <h4>Card-containter layout</h4>

    <ul>
        <li><p>Text is rendered inside a center aligned container with a max width of 600px.</p></li>
        <li><p>Suitable for markdown documents, documentation, etc.</p></li>
    </ul>
</section>

<style>
    :root {
        --unit: 8px;
    }
    * {
        font-family: Arial, sans-serif;
        font-size: calc(var(--unit) * 2);
    }
    body {
        margin: 0;
        padding: 0;
        background: var(--c-0-15);
    }
    main {
        margin: auto;
        max-width: 37.5rem;
    }
    h1,h2,h3,h4,p,label {
        line-height: 1.5em;
        margin: 1em 0 0.5em 0;
        color: var(--c-0-0);
        max-width: 37.5rem;
    }
    h1 { font-size: 3rem; }
    h2 { font-size: 2.5rem; }
    h3 { font-size: 2rem; }
    h4 { font-size: 1.5rem; }
    p { margin: 0.5rem 0; }

    form {
        border: 0.25rem solid var(--c-0-14);
        border-radius: 1rem;
        box-shadow: 0px 0px 0px 4px var(--c-0-14);
        padding: 1rem;
        display: flex;
        flex-direction: column;
    }

    input,select,textarea,button,fieldset,datalist,output,option,optgroup {
        min-width: 3rem;
        min-height: 3rem;
        margin: 0.5rem;
        padding: 0.5rem;
        border: 0.25rem solid var(--c-0-2);
        border-radius: 0.75rem;
    }

    {# input[type='range'] {
      overflow: hidden;
      width: 80px;
      -webkit-appearance: none;
      background-color: #9a905d;
    }
    
    input[type='range']::-webkit-slider-runnable-track {
      height: 10px;
      -webkit-appearance: none;
      color: #13bba4;
      margin-top: -1px;
    }
    
    input[type='range']::-webkit-slider-thumb {
      width: 10px;
      -webkit-appearance: none;
      height: 10px;
      cursor: ew-resize;
      background: #434343;
      box-shadow: -80px 0 0 80px #43e5f7;
    } #}

    input[type="checkbox"] {
        accent-color: var(--c-0-1);
        background: var(--c-1-14);
    }

    button,input[type="button"] {
        font-weight: bold;
        color: var(--c-0-0);
        background: var(--c-0-14);
        border: 0.25rem solid var(--c-0-2);
        box-shadow: 0 0.5rem 0 0 var(--c-0-1);
        border-radius: 0.75rem;
        min-width: 3rem;
        min-height: 3rem;
        transition: box-shadow 0.15s, transform 0.15s;
    }

    .button--action {
        color: var(--c-1-0);
        background: var(--c-1-14);
        border: 0.25rem solid var(--c-1-2);
        box-shadow: 0 0.5rem 0 0 var(--c-1-1);
    }

    .button--danger {
        color: var(--c-2-0);
        background: var(--c-2-14);
        border: 0.25rem solid var(--c-2-2);
        box-shadow: 0 0.5rem 0 0 var(--c-2-1);
    }

    .button--disabled {
        color: var(--c-0-12);
        border: 0.25rem solid var(--c-0-13);
        box-shadow: none;
    }

    button:hover,input[type="button"]:hover {
        box-shadow: 0 12px 0 0 var(--c-0-1);
        transform: translateY(-0.25rem);
    }
    button:active,input[type="button"]:active {
        box-shadow: 0 0.25rem 0 0 var(--c-0-1);
        transform: translateY(0.25rem);
    }

    .button--action:hover {
        box-shadow: 0 12px 0 0 var(--c-1-1);
    }
    .button--action:active {
        box-shadow: 0 0.25rem 0 0 var(--c-1-1);
    }

    .button--danger:hover {
        box-shadow: 0 12px 0 0 var(--c-2-1);
    }
    .button--danger:active {
        box-shadow: 0 0.25rem 0 0 var(--c-2-1);
    }

    .button--chip {
        box-shadow: none;
        border-radius: 3rem;
        
        color: var(--c-0-0);
        background: var(--c-0-15);
        border: 0.25rem solid var(--c-0-0);
    }
    .button--chip:hover, .button--disabled:hover {
        box-shadow: none;
        transform: none;
    }
    .button--chip:active, .button--disabled:active {
        box-shadow: none;
        transform: none;
    }

    a {
        color: var(--c-1-3);
        text-decoration: none;
        font-weight: bold;
    }

    section.card {
        border: 0.25rem solid var(--c-0-1);
        border-radius: 1rem;
        margin: 0.5rem;
        padding: 0.5rem;
    }

    #paletteCanvas {
        background: linear-gradient(in hsl longer hue to right, hsl(0,50%,50%),hsl(0, 50%, 50%));
        width: 100%;
        aspect-ratio: 360 / 50;
    }
</style>

<script>
function lerp(current, target, percent) {
    return current * (1 - percent) + target * percent;
}

function lerpTowardsCirclePoint(current, point, percent) {
    if (current > point + 180) {
        return lerp(current, point + 360, percent)
    } else if (current < point - 180) {
        return lerp(current, point - 360, percent)
    }else {
        return lerp(current, point, percent)
    }
}

function getColorRange({dynamicRange, hueShift, startingHue, saturation, saturationShift, rotations}) {
    let yellowHue = 60
    let purpleHue = 300
    let stops = []

    let brightnessStop = 100 / (dynamicRange + 1)
    for (let i = 0; i < dynamicRange; i++) {
        let brightness = brightnessStop * (i + 1)
        let hue = brightness === 50 ? startingHue
            : brightness >= 50 ? Math.round(lerpTowardsCirclePoint(startingHue, yellowHue, (hueShift * (i - (dynamicRange / 2)))))
            : Math.round(lerpTowardsCirclePoint(startingHue, purpleHue, Math.abs(hueShift * (i - (dynamicRange / 2)))))
        let s = saturation + (saturationShift * -1 * i)
        stops[i] = [hue, s, brightness]
    }

    return stops
}

function getColorPalette({startingHue, hueShift, saturation, saturationShift,  dynamicRange, rotations}) {
    let range = []
    // Set unsaturated
    {# range[0] = getColorRange({dynamicRange, hueShift:0, startingHue:0, saturation:0}) #}

    let rotationStop = Math.floor(360 / rotations)
    for (let i = 0; i < rotations; i++) {
        let hue = (startingHue + (i * rotationStop))
        range[i] = getColorRange({dynamicRange, hueShift, startingHue: hue, saturation, saturationShift})
    }

    return range
}

function createButtonsAndUpdateCssVariables(palette) {
    document.querySelector('#huePreview').innerText = ''

    let row = 0
    for (let range of palette) {
        let root = document.createElement('div')
        let column = 0
        
        let midColumn = Math.floor(range.length / 2)
        for (let stop of range) {
            let variableName = `--c-${row}-${column}`
            {# if (column == midColumn) {
                variableName = `--c-${row}-mid`
            } else #}
             {# if (column < midColumn) {
                variableName = `--c-${row}-dark-${column}`
            } else { // (column > midColumn)
                variableName = `--c-${row}-light-${Math.abs(range.length - (column + 1))}`
            } #}
            document.documentElement.style.setProperty(variableName, `hsl(${stop[0]}, ${stop[1]}%, ${stop[2]}%)`)
            let child = document.createElement('div')
            child.style = `
                background: var(${variableName}); 
                width: 100%;
                aspect-ratio: 1 / 1;
            `
            
            root.appendChild(child)
            column += 1
        }
        root.style = `
            display: flex;
            width: 100%;
        `
        
        document.querySelector('#huePreview').appendChild(root);
        row += 1
    }
}


function updateCanvas(palette) {
    const paletteCanvas = document.getElementById('paletteCanvas')
    paletteCanvas.width = paletteCanvas.clientWidth
    paletteCanvas.height = paletteCanvas.clientHeight
    const ctx = paletteCanvas.getContext("2d")
    ctx.clearRect(0, 0, paletteCanvas.width, paletteCanvas.height)
    const squareSize = paletteCanvas.height * 0.15
    const squareMidpoint = squareSize / 2

    for (range of palette) {
        for (stop of range) {
            let [hue, saturation, brightness] = stop
            if (saturation === 0) {
                continue;
            }

            ctx.beginPath()
            ctx.fillStyle = `hsl(${hue},${saturation}%,${brightness}%)`


            let x = (hue - squareMidpoint) % 360
            {
                // Wrap around canvas
                if (x < - squareMidpoint) x += 360

                // Normalize
                x = (x / 360) * paletteCanvas.width;
            }
            
            let y = stop[2] - (squareMidpoint / 2)
            {
                // Normalize
                y = (y / 100) * paletteCanvas.height
            }


            ctx.rect(x, y, squareSize, squareSize)
            ctx.fill()
            ctx.stroke()
        }
    }
}

function updatePalette() {
    const palette = getColorPalette({
            startingHue: parseInt(document.querySelector('#startingHue').value), 
            hueShift: parseFloat(document.querySelector('#shift').value) / 100, 
            saturation: parseInt(document.querySelector('#saturation').value), 
            saturationShift: parseInt(document.querySelector('#saturationShift').value) / 100, 
            dynamicRange: parseInt(document.querySelector('#dynamicRange').value), 
            rotations: parseInt(document.querySelector('#rotations').value)
        })

    createButtonsAndUpdateCssVariables(palette)
    updateCanvas(palette)
}
window.onload = updatePalette()

</script>
</main>